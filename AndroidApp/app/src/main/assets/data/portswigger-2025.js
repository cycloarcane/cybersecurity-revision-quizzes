const MASTER_POOL = [
    // --- 1. Successful Errors (SSTI) ---
    {c:"#1 Successful Errors", q:"Which new SSTI detection technique involves forcing an error that reflects the command output in the error message itself?", a:"Error-Based SSTI.", d:["Time-Based Blind SSTI.", "Boolean-Based SSTI.", "Reflection-Based SSTI."], e:"Error-Based SSTI (like causing an AttributeError in Python) forces the engine to leak data inside the error message, even if standard output is suppressed."},
    {c:"#1 Successful Errors", q:"In Korchagin's research, how is Error-Based SSTI triggered in a PHP Twig environment?", a:"By calling include() on the result of a system command.", d:["By accessing a non-existent class member.", "By causing a division by zero in a filter.", "By exceeding the maximum nesting level of blocks."], e:"In Twig, {{include(system('id'))}} results in an error like 'Template \"uid=0(root)...\" not found', effectively leaking the command output."},
    {c:"#1 Successful Errors", q:"What is the primary benefit of using Boolean Error-Based Blind SSTI over Time-Based Blind SSTI?", a:"It is more reliable and less affected by network latency.", d:["It requires fewer requests to exfiltrate a single byte.", "It bypasses all modern Web Application Firewalls.", "It does not leave any logs on the target server."], e:"Time-based attacks are prone to false positives due to network jitters; boolean error-based attacks rely on discrete HTTP status codes (e.g., 200 vs 500)."},
    {c:"#1 Successful Errors", q:"Which Python function is commonly abused in Jinja2 to trigger an AttributeError for data exfiltration?", a:"getattr().", d:["setattr().", "hasattr().", "isinstance()."], e:"getattr(obj, command_output) will fail if the attribute doesn't exist, leaking the 'command_output' string in the resulting exception message."},
    {c:"#1 Successful Errors", q:"The 'Successful Errors' research introduced universal payloads called what?", a:"Polyglots.", d:["Exploits.", "Payloads.", "Oracles."], e:"Polyglot payloads are designed to work across multiple different template engines simultaneously to simplify detection."},
    {c:"#1 Successful Errors", q:"Which open-source tool was updated to include the 'Successful Errors' SSTI methodologies?", a:"SSTImap.", d:["Sqlmap.", "Commix.", "Tplmap."], e:"SSTImap was updated by the researcher to automate these new error-based and boolean-based techniques."},
    {c:"#1 Successful Errors", q:"When an application returns a generic 500 error for any template fault, which technique is most applicable?", a:"Boolean Error-Based Blind.", d:["Reflection-Based SSTI.", "Time-Based Blind SSTI.", "Direct Error Reflection."], e:"If the specific error message is hidden but the status code changes, a boolean oracle can be used to leak data bit-by-bit."},
    {c:"#1 Successful Errors", q:"In a Java Spring EL environment, what might an attacker use to trigger an error for exfiltration?", a:"Accessing an invalid property on a retrieved object.", d:["Using a sleep() function in the expression.", "Causing an infinite loop in the template.", "Injecting a very large integer value."], e:"Similar to Python, accessing a property named after a sensitive value (like a password) causes a 'Property or field not found' error leaking that value."},
    {c:"#1 Successful Errors", q:"Why is the 'Successful Errors' research considered a significant shift in SSTI methodology?", a:"It applies proven SQLi-style exfiltration to template engines.", d:["It discovered a way to execute code without using double braces.", "It found a method to bypass sandbox restrictions in all engines.", "It focused on hardware-level side channels in web servers."], e:"It adapted mature 'blind' exfiltration concepts (error-based and boolean) from the world of SQL injection to modern template engines."},
    {c:"#1 Successful Errors", q:"What does the researcher call the side-channel used to determine the result of a boolean condition?", a:"An Oracle.", d:["A Proxy.", "A Tunnel.", "A Beacon."], e:"An oracle is a mechanism that provides a 'yes' or 'no' answer to a specific question (e.g., 'Is the first character an A?')."},
    {c:"#1 Successful Errors", q:"In Ruby's ERB engine, what might be used to trigger an informative error?", a:"Method calls on an undefined or nil object.", d:["Injecting raw HTML tags into the template.", "Using the yield keyword incorrectly.", "Causing a stack overflow via recursion."], e:"Attempting to call a method named after the target data on a nil object triggers a NoMethodError that contains the data string."},
    {c:"#1 Successful Errors", q:"Which HTTP status code is most commonly used as a 'negative' signal in Boolean Blind attacks?", a:"200 OK.", d:["500 Internal Server Error.", "403 Forbidden.", "404 Not Found."], e:"Typically, the 'positive' signal (error triggered) is a 500, and the 'negative' signal (no error) is a 200 OK."},

    // --- 2. ORM Leaking ---
    {c:"#2 ORM Leaking", q:"What is the root cause of an ORM Leak vulnerability?", a:"Unrestricted user control over query filter parameters.", d:["A buffer overflow in the database driver.", "Weak cryptographic salts in the ORM's session manager.", "Insecure default passwords in the database."], e:"ORM leaks occur when user input can directly influence complex filters (like startswith or contains) on sensitive fields or relations."},
    {c:"#2 ORM Leaking", q:"Which ORM feature is abused to reach data in connected tables during an attack?", a:"Relational Filtering (Pivoting).", d:["Object Mapping.", "Transaction Management.", "Lazy Loading."], e:"Pivoting allows an attacker to filter a query based on attributes of related objects (e.g., filtering users by their organization's secret key)."},
    {c:"#2 ORM Leaking", q:"How does an attacker perform a 'blind' ORM Leak exfiltration?", a:"By using filters like 'startswith' to guess values character-by-character.", d:["By measuring the time it takes for a query to fail.", "By monitoring the database's CPU usage during a scan.", "By intercepting unencrypted database traffic on the LAN."], e:"Similar to blind SQLi, operators like 'startswith' or 'contains' can be used as an oracle to leak secrets bit-by-bit."},
    {c:"#2 ORM Leaking", q:"Which ORM was specifically mentioned in the research regarding a vulnerability in Harbor?", a:"Beego ORM.", d:["Django ORM.", "Prisma.", "Hibernate."], e:"The researchers found a parser bug in Beego ORM that allowed them to bypass security filters in the Harbor registry."},
    {c:"#2 ORM Leaking", q:"What is a Boolean Oracle in the context of an ORM Leak?", a:"A change in the number of results returned by a search query.", d:["A specific error message returned by the ORM layer.", "The presence of a CSRF token in the response body.", "A redirect to a different login page for valid users."], e:"An attacker can infer the truth of a guess (e.g., 'Does the key start with A?') by checking if any results are returned."},
    {c:"#2 ORM Leaking", q:"Which of the following is a recommended mitigation for ORM Leaks?", a:"Implementing strict allow-lists for searchable fields.", d:["Using only NoSQL databases for sensitive data.", "Increasing the database's maximum connection limit.", "Enabling SSL/TLS for all database connections."], e:"Developers should explicitly define which fields are allowed to be filtered by user input, rather than exposing the whole model."},
    {c:"#2 ORM Leaking", q:"How can ReDoS (Regular Expression Denial of Service) be used as an oracle in ORM Leaks?", a:"To create a time-based oracle when error messages are suppressed.", d:["To crash the database and prevent other users from logging in.", "To bypass WAF filters that only look for standard SQL keywords.", "To exfiltrate the entire database content in a single request."], e:"If the ORM supports regex filters, an attacker can use a 'heavy' regex that only triggers if a certain condition is met, creating a timing side-channel."},
    {c:"#2 ORM Leaking", q:"What is 'Pivoting' in an ORM Leak attack?", a:"Navigating from an exposed model to an unexposed related model.", d:["Rotating the database's master encryption key.", "Switching between different database dialects at runtime.", "Bypassing a WAF by encoding the payload in Base64."], e:"Pivoting uses the ORM's relationship mapping to query tables that the developer never intended to expose to the search feature."},
    {c:"#2 ORM Leaking", q:"Which type of ORM operator is most useful for leaking a fixed-length secret like an API key?", a:"startswith or regex.", d:["equal or not_equal.", "greater_than or less_than.", "is_null or is_not_null."], e:"Partial matching operators allow for bit-by-bit exfiltration of the secret value."},
    {c:"#2 ORM Leaking", q:"Why are OData implementations often vulnerable to ORM Leaks?", a:"They automatically translate complex URL filters into database queries.", d:["They lack support for parameterized queries and prepared statements.", "They require administrative privileges to perform any search.", "They store all data in plaintext files on the web server."], e:"OData is designed to be highly flexible, but this flexibility often exposes internal database fields to untrusted users."},
    {c:"#2 ORM Leaking", q:"What is a 'Count Oracle' in an ORM Leak?", a:"Observing differences in the total number of records returned.", d:["Counting the number of requests before a WAF blocks the IP.", "Measuring the number of bytes in the HTTP response headers.", "Tracking the number of active database sessions in real-time."], e:"If a search returns '3 items found' for one query and '0 items' for another, it reveals information about the data without reflecting it directly."},
    {c:"#2 ORM Leaking", q:"Which architectural pattern helps prevent ORM Leaks by decoupling models from the UI?", a:"DTOs (Data Transfer Objects).", d:["MVC (Model-View-Controller).", "ORM (Object-Relational Mapping).", "SPA (Single Page Application)."], e:"DTOs ensure that only specific, safe fields are mapped to the user-facing interface, keeping sensitive model relations hidden."},

    // --- 3. Novel SSRF via Redirect Loops ---
    {c:"#3 SSRF Loops", q:"The 'Novel SSRF' research by Shubham Shah primarily targets which HTTP library?", a:"libcurl.", d:["Requests (Python).", "Axios (JS).", "Go-HTTP."], e:"The technique exploits specific behaviors in libcurl and its interaction with high-level language bindings."},
    {c:"#3 SSRF Loops", q:"Which rarely-used HTTP status codes are key to this novel SSRF technique?", a:"305 (Use Proxy) and 306 (Switch Proxy).", d:["301 (Permanent) and 302 (Found).", "307 (Temporary) and 308 (Permanent).", "401 (Unauthorized) and 403 (Forbidden)."], e:"Codes 305 and 306 trigger unique, often legacy, proxy-handling logic in libcurl that can be weaponized."},
    {c:"#3 SSRF Loops", q:"What is the primary goal of the 'Redirect Loop' SSRF attack?", a:"To transform a Blind SSRF into a Non-Blind SSRF.", d:["To cause a Denial of Service by exhausting server memory.", "To bypass IP-based firewall restrictions on the edge.", "To capture the administrator's session cookies via a redirect."], e:"By manipulating the redirect chain, attackers can force the application to leak the full response of the final 'blind' target."},
    {c:"#3 SSRF Loops", q:"Why does exceeding the 'MAX_REDIRECTS' limit help the attacker?", a:"The error message may contain the full content of the redirect chain.", d:["The server automatically disables its security filters for that request.", "The connection is upgraded to a faster protocol like HTTP/2.", "The server logs the entire request body to a publicly readable file."], e:"Error handling for 'Too many redirects' often includes diagnostic information about the previous requests in the chain, leaking data."},
    {c:"#3 SSRF Loops", q:"In this technique, what happens when a 305 'Use Proxy' status is encountered?", a:"libcurl attempts to use the location header as a proxy for the next request.", d:["The request is immediately terminated with a security warning.", "The application ignores the location header and follows a standard 302.", "The server's internal proxy settings are overwritten for all users."], e:"The legacy 305 status instructs the client to use a specific proxy, which can lead to unexpected data flow control in blind SSRF scenarios."},
    {c:"#3 SSRF Loops", q:"What sensitive data is a common target for SSRF exfiltration in cloud environments?", a:"Instance Metadata Service (IMDS) credentials.", d:["The web server's SSL private keys.", "The database's transaction log files.", "The developer's SSH public keys."], e:"IMDS often provides temporary security tokens (keys) that give full access to the cloud environment if leaked via SSRF."},
    {c:"#3 SSRF Loops", q:"How does this technique bypass 'Invalid JSON' errors in blind SSRF?", a:"By leaking the raw response body in an error log or debug message.", d:["By converting the binary response into a JSON-compatible string.", "By forcing the server to return a 200 OK status instead of an error.", "By using a redirect to a server that accepts any content type."], e:"Blind SSRF often fails when it tries to parse non-JSON data (like a secret key) as JSON; the redirect chain error can leak that data before the parsing fails."},
    {c:"#3 SSRF Loops", q:"Which component's 'messy truth' is exploited in this research?", a:"Error-handling and diagnostic logging.", d:["Encryption and hashing algorithms.", "Load balancing and traffic shaping.", "Database indexing and caching."], e:"The research shows that the way libraries and applications report complex redirect errors is a goldmine for exfiltration."},
    {c:"#3 SSRF Loops", q:"What is the 'Redirect Chain' in this context?", a:"The sequence of URLs the client follows before the final error.", d:["A method for load balancing traffic across multiple CDNs.", "A security feature that prevents SSRF by tracking history.", "The path a packet takes across the internet backbones."], e:"The chain is the series of redirects (e.g., A -> B -> C) that the attacker controls to trigger the leak."},
    {c:"#3 SSRF Loops", q:"Why is this technique particularly dangerous for enterprise software?", a:"It exploits the interaction between low-level libraries and high-level code.", d:["It requires no specialized tools and can be done with a browser.", "It works even if the server is completely disconnected from the internet.", "It can decrypt the server's traffic without knowing the private key."], e:"The flaw is at the boundary between C++ bindings (libcurl) and languages like PHP, Python, or Ruby, making it hard to find and patch."},
    {c:"#3 SSRF Loops", q:"What is a 'Non-Blind SSRF'?", a:"An SSRF where the attacker can see the server's response.", d:["An SSRF that can only be detected using a time-based oracle.", "An SSRF that requires a valid session cookie to execute.", "An SSRF that only targets public-facing internet servers."], e:"Non-blind (or 'Full') SSRF is much more critical because it allows direct data exfiltration and further internal probing."},
    {c:"#3 SSRF Loops", q:"How can developers mitigate this specific redirect-based SSRF?", a:"By disabling redirect following and strictly validating status codes.", d:["By increasing the maximum redirect limit to prevent loops.", "By using a proxy for all outgoing server-side requests.", "By encrypting the target URL before the request is made."], e:"Developers should explicitly control which status codes they follow and ensure that error messages do not leak internal response data."},

    // --- 4. Unicode Normalization ---
    {c:"#4 Unicode Exploits", q:"What is the core issue described in the 'Lost in Translation' research?", a:"Inconsistency between implementation steps (Parser Differentials).", d:["A vulnerability in the UTF-8 encoding algorithm itself.", "Weaknesses in the way browsers render emoji characters.", "A lack of support for non-Latin characters in modern WAFs."], e:"The research highlights how security checks on raw input can be bypassed if the backend transforms that input afterward."},
    {c:"#4 Unicode Exploits", q:"What does 'Best-Fit Mapping' refer to in Unicode normalization?", a:"Mapping non-ASCII characters to their closest ASCII equivalent.", d:["Automatically selecting the best font for a specific character.", "Compressing Unicode strings to reduce their size in storage.", "Translating different languages into a common intermediate form."], e:"Systems (especially Windows) often map characters like '．' (U+FF0E) to '.' (U+002E) during normalization."},
    {c:"#4 Unicode Exploits", q:"Which 2024 Remote Code Execution (RCE) vulnerability was caused by Unicode best-fit mapping?", a:"CVE-2024-4577 (PHP-CGI).", d:["CVE-2024-0001 (Windows Kernel).", "CVE-2024-9999 (Chrome Browser).", "CVE-2024-1234 (Apache HTTPD)."], e:"In the PHP-CGI case, a best-fit mapping on Windows allowed attackers to inject command arguments via the query string."},
    {c:"#4 Unicode Exploits", q:"How can Unicode Normalization bypass a regex filter for path traversal?", a:"A full-width dot is ignored by the regex but later normalized to a dot.", d:["The normalization process causes a buffer overflow in the regex engine.", "Unicode characters are always treated as wildcards by regex filters.", "The normalization removes all forward slashes from the input string."], e:"If the regex only looks for '.', an attacker can use '．' (U+FF0E) to bypass the check, only for the backend to turn it back into a '.'."},
    {c:"#4 Unicode Exploits", q:"What is a 'Unicode Overflow' or 'Truncation' attack?", a:"Forcing a multi-byte character into a single-byte container.", d:["Injecting so many characters that the server's memory is exhausted.", "Using characters that are too large to be displayed in a browser.", "A method for crashing the operating system's font renderer."], e:"By using code points that result in a specific ASCII value after modulo-256 truncation, attackers can generate malicious ASCII characters."},
    {c:"#4 Unicode Exploits", q:"Which normalization form (NFC/NFD/NFKC/NFKD) is most dangerous if misused?", a:"NFKC (Compatibility Decomposition, followed by Canonical Composition).", d:["NFC (Canonical Decomposition, followed by Canonical Composition).", "NFD (Canonical Decomposition).", "NFKD (Compatibility Decomposition)."], e:"NFKC is often 'too aggressive,' transforming visually distinct characters (like circled letters) into their plain counterparts, creating bypasses."},
    {c:"#4 Unicode Exploits", q:"What is the 'Web Telephone Game' analogy in this research?", a:"Data changing form as it moves through different security layers.", d:["The delay in communication between a client and a server.", "The loss of signal when using wireless network connections.", "The process of translating a website into multiple languages."], e:"Input is parsed by a WAF, then a load balancer, then the application; each might normalize or transform it differently."},
    {c:"#4 Unicode Exploits", q:"How do 'Homoglyphs' contribute to these vulnerabilities?", a:"They look identical to ASCII but are different code points.", d:["They are used to compress the length of an attack payload.", "They trigger specific error messages in modern YAML parsers.", "They are used to bypass CSRF protection in mobile browsers."], e:"Homoglyphs (like a Cyrillic 'а' vs an ASCII 'a') can deceive filters and human reviewers alike."},
    {c:"#4 Unicode Exploits", q:"Which Burp Suite extension was updated to help identify Unicode normalization quirks?", a:"ActiveScan++.", d:["HTTP Request Smuggler.", "Autorize.", "Turbo Intruder."], e:"ActiveScan++ was updated with patterns to detect normalization-based bypasses for path traversal and SSRF."},
    {c:"#4 Unicode Exploits", q:"What is the 'Remediation' advice for Unicode-based vulnerabilities?", a:"Normalize data BEFORE performing security validation.", d:["Disable all support for non-ASCII characters in the application.", "Use a separate server to handle all Unicode-related processing.", "Encrypt all user input at the browser level before sending it."], e:"The only way to be safe is to ensure you are validating the EXACT same data that the backend logic will eventually use."},
    {c:"#4 Unicode Exploits", q:"Which CWE describes the 'Inconsistency Between Implementation' issue?", a:"CWE-180.", d:["CWE-79 (XSS).", "CWE-89 (SQLi).", "CWE-22 (Path Traversal)."], e:"CWE-180 refers to discrepancies in how different steps in a process handle the same data."},
    {c:"#4 Unicode Exploits", q:"How does the Turkish 'I' issue affect security filters?", a:"'I' might not map to 'i' correctly in case-insensitive checks.", d:["It causes a permanent crash in the Java Runtime Environment.", "It allows for unlimited storage of data in the session cookie.", "It bypasses the Same-Origin Policy in most modern browsers."], e:"The distinct 'İ'/'i' and 'I'/'ı' mapping in Turkish can lead to auth bypasses or filter misses if the locale is not handled correctly."},

    // --- 5. SOAPwn ---
    {c:"#5 SOAPwn", q:"Which .NET class is at the heart of the SOAPwn class of vulnerabilities?", a:"HttpWebClientProtocol.", d:["System.Net.Http.HttpClient.", "System.Net.WebClient.", "System.ServiceModel.ClientBase."], e:"Legacy SOAP proxy classes in .NET, starting with HttpWebClientProtocol, were found to have a dangerous default behavior."},
    {c:"#5 SOAPwn", q:"What is the 'unexpected protocol support' that makes SOAPwn possible?", a:"The classes allow file:// and UNC paths in place of URLs.", d:["They automatically support the deprecated Gopher protocol.", "They can communicate via Bluetooth on mobile devices.", "They allow the use of SSH for web service communication."], e:"The framework uses WebRequest.Create() without validating the scheme, allowing local or network file paths."},
    {c:"#5 SOAPwn", q:"How is Remote Code Execution (RCE) typically achieved via SOAPwn?", a:"By writing a malicious webshell (like ASPX) to the local disk.", d:["By overflowing the heap in the .NET Garbage Collector.", "By stealing the server's machine key and forging tokens.", "By triggering a use-after-free bug in the WSDL parser."], e:"Attackers force the app to 'send' a SOAP request (containing the webshell) to a local path like C:\\inetpub\\wwwroot\\shell.aspx."},
    {c:"#5 SOAPwn", q:"What is the primary role of WSDL (Web Services Description Language) in this attack?", a:"An attacker-controlled WSDL defines the malicious target path.", d:["The WSDL contains the binary payload for the RCE attack.", "The WSDL encrypts the communication to bypass WAF filters.", "The WSDL is used to scan the internal network for open ports."], e:"Tricking an application into importing a malicious WSDL allows the attacker to control the generated proxy's target URL."},
    {c:"#5 SOAPwn", q:"Which high-profile RMM (Remote Monitoring and Management) tool was found vulnerable to SOAPwn?", a:"Barracuda Service Center (CVE-2025-34392).", d:["SolarWinds Orion.", "Kaseya VSA.", "ConnectWise ScreenConnect."], e:"Barracuda's tool was vulnerable to unauthenticated RCE through a pre-auth SOAP API that imported WSDLs."},
    {c:"#5 SOAPwn", q:"Besides RCE, what is another potential impact of pointing a SOAPwn URL to a UNC path?", a:"NTLM Relay attacks.", d:["Cross-Site Scripting (XSS).", "Denial of Service (DoS).", "Parameter Tampering."], e:"By pointing the URL to a malicious SMB share (\\\\attacker\\share), the attacker can capture or relay the server's NTLM credentials."},
    {c:"#5 SOAPwn", q:"Why did Microsoft reportedly decline to issue a framework-level patch for SOAPwn?", a:"They classify the behavior as a 'feature' rather than a bug.", d:["They claim that no current .NET applications are affected.", "They stated that the .NET Framework is no longer supported.", "They believe the attack is too complex to be executed in reality."], e:"Microsoft considers the responsibility for URL validation to lie with the developer, not the framework protocol classes."},
    {c:"#5 SOAPwn", q:"Which .NET class is often used to dynamically generate client proxies from WSDL files?", a:"ServiceDescriptionImporter.", d:["SoapFormatter.", "XmlSerializer.", "WsdlParser."], e:"ServiceDescriptionImporter is commonly abused to import malicious WSDLs and generate the vulnerable proxies."},
    {c:"#5 SOAPwn", q:"In the Ivanti Endpoint Manager (EPM) case (CVE-2025-13659), what was the vulnerability?", a:"RCE through malicious WSDL imports.", d:["SQL Injection in the web management console.", "XSS in the client-side reporting dashboard.", "Auth bypass via a hardcoded administrative password."], e:"Ivanti EPM was one of the major products shown to be susceptible to the SOAPwn class of RCE attacks."},
    {c:"#5 SOAPwn", q:"What happens when a SOAPwn-vulnerable class is given a file:// path?", a:"It writes the SOAP request body to that file.", d:["It attempts to execute the file as a local process.", "It reads the file and returns it in the SOAP response.", "It ignores the path and throws an 'Invalid URL' exception."], e:"Instead of an HTTP POST, the 'request' becomes a local file write operation."},
    {c:"#5 SOAPwn", q:"Which legacy .NET technology is the primary target of this research?", a:"ASMX Web Services.", d:["WCF (Windows Communication Foundation).", "ASP.NET Core Minimal APIs.", "Web API 2 (RESTful)."], e:"ASMX (SoapHttpClientProtocol) is the legacy stack where this architectural flaw is most prevalent."},
    {c:"#5 SOAPwn", q:"What is the recommended defense for developers using legacy SOAP proxies?", a:"Strictly validate that URLs use only http or https schemes.", d:["Use only the latest version of the .NET Framework.", "Enable the built-in .NET anti-XSS and anti-SQLi filters.", "Convert all SOAP services into modern RESTful APIs immediately."], e:"Since Microsoft won't patch it, developers must manually ensure that URL schemes are restricted and WSDL sources are trusted."},

    // --- 6. Cross-Site ETag Length Leak ---
    {c:"#6 ETag Leak", q:"What information does the 'Cross-Site ETag Length Leak' exfiltrate?", a:"The length (in hex) of a response's ETag header.", d:["The full content of the ETag's secret hashing key.", "The user's plaintext password stored in the ETag.", "The server's internal IP address and timestamp."], e:"The leak uses the fact that many ETags contain the hexadecimal representation of the response size."},
    {c:"#6 ETag Leak", q:"Why does the hexadecimal representation of size create a leak?", a:"The ETag string length changes when crossing hex boundaries.", d:["Hexadecimal characters are easier to guess than decimal ones.", "Hexadecimal encoding is not supported by modern WAFs.", "The ETag becomes shorter when a search query finds a match."], e:"For example, going from 0xfff (3 chars) to 0x1000 (4 chars) increases the ETag length by one byte."},
    {c:"#6 ETag Leak", q:"Which HTTP header is used by the browser to send a previously received ETag back to the server?", a:"If-None-Match.", d:["If-Modified-Since.", "Cache-Control.", "Authorization."], e:"Browsers use 'If-None-Match' to check if their cached version of a resource is still valid."},
    {c:"#6 ETag Leak", q:"What is the 'Oracle' used in the ETag Length Leak attack?", a:"A 431 Request Header Fields Too Large error.", d:["A 404 Not Found error for invalid search results.", "A 500 Internal Server Error when a secret is guessed.", "A 302 Redirect to an attacker-controlled login page."], e:"The attacker pads the request so that a 1-byte increase in the ETag pushes the total header size over the server's limit."},
    {c:"#6 ETag Leak", q:"How is the 431 error detected cross-origin in Chromium?", a:"By checking history.length after a failed navigation.", d:["By monitoring the browser's console logs via JavaScript.", "By measuring the time it takes for the server to respond.", "By using a service worker to intercept the error response."], e:"In Chromium, a navigation failure (like a 431) may 'replace' the history entry, which can be detected by an origin-crossing script."},
    {c:"#6 ETag Leak", q:"Which server-side component often generates ETags containing the hex size?", a:"The 'jshttp/etag' library or Apache/Nginx defaults.", d:["The database's primary key generation logic.", "The WAF's session-tracking middleware layer.", "The browser's internal caching engine."], e:"Standard libraries and web servers often include size and last-modified time in the ETag for efficiency."},
    {c:"#6 ETag Leak", q:"What type of data exfiltration is possible with this technique?", a:"Character-by-character exfiltration of private data.", d:["A full dump of the entire server-side database.", "The theft of the server's SSL/TLS private keys.", "The capture of all outgoing user passwords."], e:"By using search filters or adding/removing characters, an attacker can use the oracle to leak data bit-by-bit."},
    {c:"#6 ETag Leak", q:"Why is this leak considered 'harder to patch' than other XS-Leaks?", a:"It relies on fundamental HTTP caching and header limits.", d:["It requires a hardware-level change in the server's CPU.", "It bypasses the Same-Origin Policy at the network layer.", "It works even if the user has disabled all JavaScript."], e:"Caching (ETags) and header limits are core to web performance; removing them is difficult for most sites."},
    {c:"#6 ETag Leak", q:"In this attack, why does the attacker 'pad' the request headers?", a:"To reach the server's maximum header size limit (e.g., 8KB).", d:["To confuse the WAF into thinking it is a DDoS attack.", "To bypass CSRF protections like 'SameSite' cookies.", "To ensure the request is not cached by an intermediate CDN."], e:"Padding (via long cookies or URLs) makes the request 'fragile' so that a tiny change in the ETag triggers an error."},
    {c:"#6 ETag Leak", q:"What is an 'XS-Leak' (Cross-Site Leak)?", a:"A side-channel that reveals info across origins.", d:["An attack where a script is executed on a different site.", "A vulnerability that allows direct access to private APIs.", "A method for stealing cookies from a different browser."], e:"XS-Leaks use browser side-channels (time, size, errors) to leak information that the SOP should protect."},
    {c:"#6 ETag Leak", q:"Which researcher discovered the Cross-Site ETag Length Leak?", a:"Takeshi Kaneko (@arkark_).", d:["James Kettle.", "Shubham Shah.", "Salvatore Abello."], e:"Takeshi Kaneko's research into ETag-based XS-Leaks took the #6 spot in the 2025 list."},
    {c:"#6 ETag Leak", q:"What happens when a search query returns more results, in terms of the ETag?", a:"The response body grows, potentially increasing the ETag hex size.", d:["The ETag is removed to prevent caching of dynamic results.", "The ETag is encrypted with a new key to protect the data.", "The ETag becomes shorter to save bandwidth for the user."], e:"Larger responses have larger hex-encoded sizes in their ETags, which is the core signal for this attack."},

    // --- 7. Next.js Cache Poisoning ---
    {c:"#7 Next.js Cache", q:"What is the name of the high-impact vulnerability research on Next.js caching?", a:"Next.js, cache, and chains: the stale elixir.", d:["Next-Gen Request Smuggling.", "The Next.js Deception.", "Cache and Carry: Next.js Exploits."], e:"The research (CVE-2024-46982) by zhero explored complex attack chains targeting Next.js internal caching."},
    {c:"#7 Next.js Cache", q:"Next.js uses an internal parameter to identify 'Data Requests'—what is it?", a:"__nextDataReq.", d:["__nextCacheReq.", "__nextInternal.", "__nextSsrData."], e:"__nextDataReq is a query parameter used by the framework to fetch JSON data for client-side navigation."},
    {c:"#7 Next.js Cache", q:"How does an attacker poison the Next.js cache using this technique?", a:"By tricking SSR pages into using SSG (Static) caching logic.", d:["By overflowing the memory of the internal cache store.", "By injecting malicious data directly into the Redis backend.", "By stealing the framework's secret caching key from logs."], e:"By combining specific parameters and headers, attackers can force dynamic, user-specific pages to be cached as static assets."},
    {c:"#7 Next.js Cache", q:"Which header can influence how the Next.js framework interprets a route in this attack?", a:"x-now-route-matches.", d:["x-nextjs-data.", "x-forwarded-host.", "x-cache-control."], e:"The research showed that x-now-route-matches could be used to manipulate internal routing and caching logic."},
    {c:"#7 Next.js Cache", q:"What is a potential impact of this Next.js cache poisoning?", a:"Stored XSS or Web Cache Deception.", d:["Immediate root access to the underlying server.", "The ability to decrypt all HTTPS traffic to the site.", "A bypass of the browser's Same-Origin Policy."], e:"If the dynamic page reflects user input, poisoning the cache leads to Stored XSS for all subsequent visitors."},
    {c:"#7 Next.js Cache", q:"How can this vulnerability lead to a Denial of Service (DoS)?", a:"By poisoning a page's URL with a JSON data response.", d:["By overwhelming the cache with millions of unique keys.", "By crashing the server's Node.js process via a large header.", "By deleting the entire cache database via a special request."], e:"If the cache is poisoned with a 'Data Request' response, regular users visiting the URL get a JSON object instead of a website."},
    {c:"#7 Next.js Cache", q:"Which Next.js router was primarily targeted by this research?", a:"Pages Router (getServerSideProps).", d:["App Router (Server Components).", "API Router.", "Middleware Router."], e:"The research focused on the traditional Pages Router and its handling of SSR vs. SSG transitions."},
    {c:"#7 Next.js Cache", q:"In which Next.js versions was the 'Stale Elixir' vulnerability patched?", a:"13.5.7 and 14.2.10+.", d:["11.0.0 and 12.0.0.", "15.0.0 (Pre-release only).", "It remains unpatched in all current versions."], e:"The vulnerability was significant enough to require back-ported patches in both the 13.x and 14.x branches."},
    {c:"#7 Next.js Cache", q:"What is 'Web Cache Deception' in the context of Next.js?", a:"Tricking a CDN into caching private, authenticated SSR data.", d:["Making the browser believe a malicious site is the real one.", "Displaying a fake 'Maintenance' page to legitimate users.", "A method for stealing CSRF tokens from the browser's memory."], e:"If a private user page is cached as 'static,' an attacker can access the victim's data by visiting that static URL."},
    {c:"#7 Next.js Cache", q:"Why does this attack work even without an external CDN?", a:"Next.js has its own internal framework-level cache.", d:["The attack exploits a flaw in the user's browser cache.", "It uses the server's RAM as a temporary data storage.", "It relies on a shared cache between the client and server."], e:"Unlike traditional cache poisoning, this research targets the cache managed directly by the Next.js framework itself."},
    {c:"#7 Next.js Cache", q:"What is 'SSR' in the context of Next.js?", a:"Server-Side Rendering.", d:["Static Site Rendering.", "Security Site Review.", "Server-Side Request."], e:"SSR is the process of generating HTML for a page on the server for every unique request."},
    {c:"#7 Next.js Cache", q:"Which 'Data Request' header is used to trigger JSON fetching in Next.js?", a:"x-nextjs-data.", d:["x-requested-with.", "x-next-ssr.", "x-data-only."], e:"Next.js uses x-nextjs-data to differentiate between a full page load and a client-side navigation request for data."},

    // --- 8. Cross-Site Redirect Leaks ---
    {c:"#8 Redirect Leaks", q:"The 'XSS-Leak' research by Salvatore Abello targets which browser component?", a:"Chrome's connection-pool prioritization algorithm.", d:["The JavaScript V8 engine's memory allocator.", "The browser's internal URL parsing library.", "The Cookie storage and management system."], e:"The attack (also known as Cross-Site Subdomain Leak) uses the connection pool as a side-channel oracle."},
    {c:"#8 Redirect Leaks", q:"What is the 'Oracle' used to leak redirect destinations in this attack?", a:"Resource scheduling and connection timing.", d:["An error message reflected in the address bar.", "A change in the browser's window.location property.", "The presence of a specific cookie in the request."], e:"By measuring how a probe request is delayed by a redirect, the attacker can infer the redirect's destination origin."},
    {c:"#8 Redirect Leaks", q:"How many concurrent connections per origin does Chrome typically allow?", a:"6 connections.", d:["1 connection.", "10 connections.", "Unlimited connections."], e:"Chrome enforces a limit of 6 connections per origin, which is the limit exploited in many connection-pool attacks."},
    {c:"#8 Redirect Leaks", q:"When requests have the same priority, what is the 'deterministic' sorting order in Chrome?", a:"Port → Scheme → Host (alphabetically).", d:["Timestamp → Size → Origin.", "Randomized for security reasons.", "First-in, First-out (FIFO)."], e:"Crucially, Chrome sorts identical-priority requests alphabetically by host, allowing for a binary search-style leak."},
    {c:"#8 Redirect Leaks", q:"How can an attacker use 'Alphabetical Leaking' to find a subdomain?", a:"By comparing a probe's delay against candidate hostnames.", d:["By guessing the subdomain and checking for a 404 error.", "By forcing the browser to visit every possible subdomain.", "By stealing the browser's autocomplete history for the site."], e:"By placing a probe request in the queue along with a 'guess,' the attacker can tell if the guess comes before or after the real target alphabetically."},
    {c:"#8 Redirect Leaks", q:"Why is the name 'XSS-Leak' potentially confusing for this research?", a:"It has nothing to do with Cross-Site Scripting (XSS).", d:["It only works if the target site has an XSS vulnerability.", "It is a new type of XSS that only affects the Chromium browser.", "The researcher accidentally used the wrong name in the paper."], e:"The name is a play on 'XS-Leak,' but it is purely a side-channel attack, not an injection attack like XSS."},
    {c:"#8 Redirect Leaks", q:"What is the primary security impact of leaking cross-origin redirects?", a:"Bypassing the Same-Origin Policy to deanonymize users.", d:["Gaining full Remote Code Execution on the user's machine.", "Decrypting the user's stored passwords in the browser.", "Resetting the user's multi-factor authentication settings."], e:"Leaking where a user is redirected (e.g., a user-specific subdomain) can reveal their identity or sensitive session tokens."},
    {c:"#8 Redirect Leaks", q:"Why is this vulnerability difficult for browser vendors to patch?", a:"It targets a fundamental performance optimization.", d:["It requires a complete rewrite of the TCP/IP stack.", "It affects only a very small number of legacy websites.", "It would require a hardware-level change in all Wi-Fi chips."], e:"Prioritizing and pooling connections is essential for web performance; removing the side-channel without hurting speed is a major challenge."},
    {c:"#8 Redirect Leaks", q:"What is 'Connection Pool Flooding'?", a:"Exhausting all available connections to create an oracle.", d:["A type of DDoS attack that crashes the web server.", "Filling the browser's cache with thousands of large images.", "Sending so many cookies that the server returns a 431 error."], e:"By filling the 6-connection limit, the attacker forces the next request (the redirect or probe) into a queue where it can be measured."},
    {c:"#8 Redirect Leaks", q:"Which blog published the original research as 'Cross-Site Subdomain Leak'?", a:"blog.babelo.xyz.", d:["portswigger.net.", "assetnote.io.", "elttam.com.au."], e:"Salvatore Abello's blog detailed the alphabetical sorting side-channel in Chromium."},
    {c:"#8 Redirect Leaks", q:"How does an attacker detect which request was processed first?", a:"By measuring the execution time of a 'probe' request.", d:["By checking the browser's internal chrome://net-export log.", "By intercepting the network traffic with a local proxy.", "By reading the response body of the cross-origin requests."], e:"JavaScript can time how long a fetch() takes; if it's delayed, it means other requests in the queue were prioritized over it."},
    {c:"#8 Redirect Leaks", q:"Can this attack leak the full path of a redirect, or just the origin?", a:"Primarily just the origin (Subdomain/Host).", d:["It can leak the full URL including query parameters.", "It can only leak the top-level domain (e.g., .com).", "It can leak the user's IP address but not the hostname."], e:"Because the sorting is by hostname, the leak is restricted to determining which host/subdomain the user was sent to."},

    // --- 9. HTTP/2 CONNECT ---
    {c:"#9 HTTP/2 Connect", q:"What is the primary difference in how 'CONNECT' works in HTTP/2 vs HTTP/1.1?", a:"HTTP/2 uses single streams; HTTP/1.1 uses whole connections.", d:["HTTP/2 requires encryption; HTTP/1.1 is always plaintext.", "HTTP/2 is faster for downloads; HTTP/1.1 is faster for uploads.", "HTTP/2 is only for browsers; HTTP/1.1 is for all apps."], e:"In HTTP/1.1, CONNECT takes over the TCP link. In HTTP/2, it is just one of many multiplexed streams."},
    {c:"#9 HTTP/2 Connect", q:"How can 'Multiplexed Tunneling' be weaponized by an attacker?", a:"By opening hundreds of internal tunnels over one TCP connection.", d:["By intercepting other users' traffic on the same server.", "By crashing the server with a single massive DATA frame.", "By bypassing the server's SSL/TLS certificate verification."], e:"HTTP/2 allows parallel streams, enabling fast, parallelized internal scanning through a single edge connection."},
    {c:"#9 HTTP/2 Connect", q:"What is a common security bypass made possible by HTTP/2 CONNECT?", a:"NIDS failing to inspect encapsulated multiplexed streams.", d:["Bypassing the Same-Origin Policy in modern browsers.", "Resetting the server's administrative password via a tunnel.", "Executing raw SQL queries directly through the load balancer."], e:"Many security tools only look at the TCP/HTTP/2 headers and fail to 'see' the tunneled data inside the streams."},
    {c:"#9 HTTP/2 Connect", q:"Which researcher developed the 'Playing with HTTP/2 CONNECT' paper?", a:"Florian Meyer (@flomb).", d:["James Kettle.", "Piotr Bazydlo.", "Joern Schneeweisz."], e:"Florian Meyer's research into HTTP/2 tunneling was ranked #9 in the 2025 list."},
    {c:"#9 HTTP/2 Connect", q:"What internal network activity is highly efficient via HTTP/2 CONNECT tunnels?", a:"Internal Port Scanning.", d:["Database Credential Stuffing.", "File System Enumeration.", "Wireless Signal Jamming."], e:"An attacker can probe hundreds of internal IP/port combinations simultaneously using multiplexed streams."},
    {c:"#9 HTTP/2 Connect", q:"What tool was released to help identify and exploit HTTP/2 CONNECT misconfigurations?", a:"HTTP2-CONNECT-Tunnel.", d:["H2Spec.", "Burp Suite H2 Smuggler.", "Nghttp2-Scanner."], e:"The researcher released a tool specifically to leverage multiplexing for internal scanning and tunneling."},
    {c:"#9 HTTP/2 Connect", q:"How is data carried within an HTTP/2 CONNECT tunnel?", a:"Inside standard HTTP/2 DATA frames.", d:["Within the URL query string of the request.", "In the 'Proxy-Authorization' header fields.", "As raw binary data outside of the HTTP/2 protocol."], e:"The tunneled traffic is encapsulated in DATA frames, making it indistinguishable from normal multiplexed traffic to basic filters."},
    {c:"#9 HTTP/2 Connect", q:"Why is HTTP/2 CONNECT tunneling 'stealthier' than traditional methods?", a:"It requires only one TCP handshake for many internal probes.", d:["It uses a specialized encryption that WAFs cannot crack.", "It only works on mobile devices and bypasses desktop logs.", "It deletes the server's access logs automatically after use."], e:"Traditional scans require many new TCP connections (SYN packets), which is much easier for an IDS to detect than a single stream-based scan."},
    {c:"#9 HTTP/2 Connect", q:"What is 'Multiplexing' in the context of HTTP/2?", a:"Sending multiple requests/responses over one TCP connection.", d:["Automatically translating HTTP/2 into HTTP/1.1 for legacy sites.", "Using multiple server IP addresses to handle a single request.", "Encrypting the same message with multiple different keys."], e:"Multiplexing is the core feature of HTTP/2 that allows concurrent streams over a single shared connection."},
    {c:"#9 HTTP/2 Connect", q:"In this attack, what does a status code 200 after a CONNECT request mean?", a:"The tunnel to the target IP/port was successfully established.", d:["The server refused the request for security reasons.", "The target IP/port is closed or filtered by a firewall.", "The server requires a valid session cookie to proceed."], e:"A 200 response to CONNECT indicates that the proxy/load-balancer successfully connected to the internal target."},
    {c:"#9 HTTP/2 Connect", q:"Which misconfiguration is required for this attack to be successful?", a:"Allowing CONNECT to untrusted internal IP ranges.", d:["Using an outdated version of the OpenSSL library.", "Disabling HTTP/2 support on the edge load balancer.", "Enabling 'Strict-Transport-Security' headers."], e:"The edge server (proxy/LB) must be willing to proxy CONNECT requests to sensitive internal destinations."},
    {c:"#9 HTTP/2 Connect", q:"How can network administrators defend against this technique?", a:"Restrict CONNECT destinations to a specific allow-list.", d:["Block all HTTP/2 traffic at the network perimeter.", "Require a unique password for every HTTP/2 stream.", "Disable the 'DATA' frame type in the HTTP/2 configuration."], e:"Admins should limit which hosts and ports the edge server is permitted to tunnel to using the CONNECT method."},

    // --- 10. Parser Differentials ---
    {c:"#10 Parser Differentials", q:"What is a 'Parser Differential'?", a:"When two components interpret the same input differently.", d:["A method for calculating the speed of a network packet.", "A vulnerability in the way browsers render CSS styles.", "A discrepancy between the code in dev and production."], e:"Parser differentials (or discrepancies) are the root cause of attacks like Request Smuggling and WAF Bypasses."},
    {c:"#10 Parser Differentials", q:"Why are parser differentials called 'meta-vulnerabilities'?", a:"They are the underlying cause of many other attack types.", d:["They only exist in the 'meta' tags of an HTML document.", "They require a deep understanding of metaphysical principles.", "They were first discovered in the Meta (Facebook) tech stack."], e:"Discrepancies in parsing URLs, headers, or JSON often lead to SSRF, Auth Bypass, or Smuggling."},
    {c:"#10 Parser Differentials", q:"Which researcher's framework for identifying these discrepancies was ranked #10?", a:"Joern Schneeweisz (@joernchen).", d:["James Kettle.", "Vladislav Korchagin.", "Shubham Shah."], e:"Joern's research on systematic parser differential identification was a key contribution to the 2025 list."},
    {c:"#10 Parser Differentials", q:"Which file format was highlighted as having dangerous parser quirks in modern libraries?", a:"YAML.", d:["JSON.", "XML.", "CSV."], e:"YAML parsers (e.g., in Python or Ruby) often have complex behaviors regarding duplicate keys or custom tags that lead to differentials."},
    {c:"#10 Parser Differentials", q:"How can a parser differential lead to a WAF bypass?", a:"The WAF sees a safe request, but the backend sees a malicious one.", d:["The WAF crashes when it encounters a specific character.", "The attacker uses a different font that the WAF cannot read.", "The WAF is tricked into thinking the attacker is an admin."], e:"If the WAF and backend disagree on where a parameter ends or how a character is decoded, the WAF's check becomes useless."},
    {c:"#10 Parser Differentials", q:"James Kettle's 'Desync Endgame' research targets which type of servers?", a:"Major CDNs like Akamai, Cloudflare, and Netlify.", d:["Internal private databases not connected to the web.", "Small, self-hosted WordPress sites on shared hosting.", "Mobile application backends using GraphQL APIs."], e:"Kettle's latest research focused on finding deep parser discrepancies in highly hardened, enterprise-grade CDNs."},
    {c:"#10 Parser Differentials", q:"What is 'HTTP Request Smuggling' a specific type of?", a:"Parser Differential vulnerability.", d:["Cross-Site Scripting (XSS) attack.", "Insecure Direct Object Reference (IDOR).", "Local File Inclusion (LFI)."], e:"Request Smuggling is a differential in how front-end and back-end servers parse the Content-Length or Transfer-Encoding headers."},
    {c:"#10 Parser Differentials", q:"In YAML, what might cause a differential between two different parser implementations?", a:"Handling of duplicate keys or specific !! tags.", d:["The number of spaces used for indentation in the file.", "The use of single vs double quotes for string values.", "The presence of comments at the end of the document."], e:"Different YAML libraries follow different versions of the spec or have unique ways of handling duplicate keys or object tags."},
    {c:"#10 Parser Differentials", q:"Which tool was integrated with 'v3' capabilities to find these desync discrepancies?", a:"HTTP Request Smuggler (Burp Extension).", d:["SQLmap.", "Dirsearch.", "Gau."], e:"The HTTP Request Smuggler extension was significantly updated by James Kettle to find modern desync vulnerabilities."},
    {c:"#10 Parser Differentials", q:"What is the fundamental rule for avoiding parser differentials?", a:"Use the same, well-vetted library across the entire stack.", d:["Always encode all user input in Base64 before parsing.", "Manually verify every request using a human reviewer.", "Disable all types of parsing and use only raw byte strings."], e:"Standardization and using robust, RFC-compliant parsers consistently across all layers is the best defense."},
    {c:"#10 Parser Differentials", q:"Which RFC interpretation discrepancy is a classic source of differentials?", a:"How to handle multiple 'Host' headers or trailing spaces.", d:["The maximum number of colors allowed on a web page.", "The recommended font size for mobile browser display.", "The use of 'dark mode' by default in user preferences."], e:"Ambiguities in the HTTP RFCs regarding duplicate headers or whitespace are frequent sources of parsing discrepancies."},
    {c:"#10 Parser Differentials", q:"What does 'interpretation becomes a vulnerability' mean in this context?", a:"The way a server reads data is the actual flaw, not the data itself.", d:["Attacks only work if the user interprets the data as malicious.", "The researcher's interpretation of the logs was incorrect.", "The WAF interprets every request as a potential attack."], e:"The vulnerability arises from the disagreement between two parsers, rather than a traditional 'bad' character in the input."}
];
